# -*- coding: utf-8 -*-
"""task1a.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14opCP4LVW0WsMQ7wlck7lz9PCitCDm0k
"""

def Graph(gdict=None):
    if gdict is None:
        gdict = {}
    return gdict

def addEdge(gdict, vertex, edge):
    if vertex not in gdict:
        gdict[vertex] = [edge]
    else:
        gdict[vertex].append(edge)
    # Ensure that every node appears in the graph, even if it has no outgoing edges.
    if edge not in gdict:
        gdict[edge] = []

#task 1 dfs
'''
here i have used dfs method to top sort the graph.then i have used is cyclic function to
to detect cycle .if a cycle occurs it means top sort can't happen.if there is no cycle i have
used dfs to do the sort
'''
import numpy as np
#for opening file
boi= open ("input1a.txt","r")
khata= open("output1a.txt","w")

x,y = list(map(int,boi.readline().split()))
graph1=Graph()
for i in range(y):
    a,b =list(map(int,boi.readline().split()))
    #a-->b
    addEdge(graph1, a,b)

#print(graph1)
# cycle detection function

def isCyclic(G):
    visited = {}
    path = {}

    for i in G:
        visited[i] = False
        path[i] = False


    for i in G:
        if not visited[i]:
            if DFS_detect_cycle(G, i, visited, path):
                return True

    return False

def DFS_detect_cycle(G, s, visited, path):
    visited[s] = True
    path[s] = True

    for v in G[s]:
        if not visited[v]:
            if DFS_detect_cycle(G, v, visited, path):
                return True

        elif path[v]:
            return True

    # Remove the current vertex from the path since we are backtracking
    path[s] = False
    return False
#main task
def topologicalSortUtil(graph, v, visited, stack):
    if v not in visited:  # Check if not visited before proceeding
        visited.append(v)

        if v in graph:  # Check if the vertex has outgoing edges
            for i in graph[v]:
                topologicalSortUtil(graph, i, visited, stack)
        stack.insert(0, v)  # Insert the vertex in the stack

def topologicalSort(graph):
    s=""
    if isCyclic(graph):
        print("Impossible")
        s="IMPOSSIBLE"
    else:

        visited = []  # Use a list for visited vertices
        stack = []

        for k in graph:
            if k not in visited:
                topologicalSortUtil(graph, k, visited, stack)

        print(stack)
        for i in stack :
            s+=str(i)+" "
    khata.write (s)
    print(s)

topologicalSort(graph1)