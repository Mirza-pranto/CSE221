# -*- coding: utf-8 -*-
"""task2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14opCP4LVW0WsMQ7wlck7lz9PCitCDm0k
"""

#task 2
'''
here i have used a the previous bfs top sort tecniq just with little bit change .
and that is i have used heap queue insted of normal queue . just to get the minimum
node value from the heap.
'''
import heapq


def isCyclic(G):
    visited = {}
    path = {}

    for i in G:
        visited[i] = False
        path[i] = False


    for i in G:
        if not visited[i]:
            if DFS_detect_cycle(G, i, visited, path):
                return True

    return False

def DFS_detect_cycle(G, s, visited, path):
    visited[s] = True
    path[s] = True

    for v in G[s]:
        if not visited[v]:
            if DFS_detect_cycle(G, v, visited, path):
                return True

        elif path[v]:
            return True

    # Remove the current vertex from the path since we are backtracking
    path[s] = False
    return False

def kahn (graph, visited, indegre):
    s=""
    if isCyclic(graph):
        print("IMPOSSIBLE")
        s= "IMPOSSIBLE"

    else: # main kahn algo starts from here
        heap = [ ]

        for key in list(indegre.keys()):
            if indegre [key] == 0:
                heapq.heappush(heap, key)
                visited[ key ] = True

        while heap:
            temp = heapq.heappop(heap)
            print(temp)
            s+=str(temp)+" "
            for child in graph [ temp ]:
                if not visited [ child]:
                    indegre [ child ] -=1
                    if indegre [ child ]==0:
                        heapq.heappush(heap, child)
                        visited [child] = True
        print(s)
        khata.write(s)



#for opening file
boi= open ("input2.txt","r")
khata= open("output2.txt","w")

x,y = list(map(int,boi.readline().split()))
graph={}
visited = {}
indegre = {}
for i in range(1, x+1):
    graph[i] = []
    visited[i] = False
    indegre [ i] = 0
for i in range (y):
    u,v = list(map(int,boi.readline().split()))
    graph[u] . append(v)
    indegre[v] +=1





print(graph)
print(indegre)
kahn(graph, visited, indegre)